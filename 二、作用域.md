## 1.命名空间(namespace)
定义：将全局作用域分成不同的、具名的作用域，可以有效防止全局作用域的命名冲突。
缺点：和类一样提供了额外的命名轴线。在头文件中使用不具名空间容易违反C++为已定义原则。
## a.不具名命名空间
namespace{               // .cc文件中

} // namespace
与特定类关联的文件作用域声明在该类中被声明为类型、静态数据成员或静态成员函
数，而不是不具名命名空间的成员

### b.具名命名空间
命名空间将除文件包含，全局标识的声明/定义和类的前置声明外的整个源文件封装起来。
// .h 文件
namespace my_namespace{
// 所有声明至于命名空间中
} // namespace my_namespace
// .cc文件
namespace my_namespace{
// 函数定义都置于命名空间中
}// namespace my_namespace

最好不使用 using ，以保证命名空间下的所有名称都可以正常使用。
在.cc文件、.h文件的函数、方法或类中可以使用 using。
可以使用别名。


### 2.嵌套类
class Foo {
private:
// Bar 是嵌套在Foo 中的成员类
class Bar {
...
};
};
在类中定义另一个类，也成为成员类。
公开嵌套类作为接口的一部分时，可以在全局作用域中，但是声明在命名空间中更好。
优点：将其置于被嵌套类中，作为被嵌套类的成员，不会污染其他作用域的同名类。
缺点：只能在被嵌套类的定义中才能前置声明嵌套类。因此，任何使用Foo::Bar*指针的
头文件必须包含整个Foo 的声明。
***除非是接口的一部分，不使用public。

## 3.非成员函数、静态成员函数、全局函数
使用命名成员中的 非成员函数 或 静态成员函数，尽量不使用全局函数。

相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用命名空间。

## 4.局部变量
置于最小作用域--离第一次使用越近越好，初始化。

## 5.全局变量
class 类型的全局变量是被禁止的，内建类型的全局变量是允许的，当然多线程代码中非常
数全局变量也是被禁止的。永远不要使用函数返回值初始化全局变量。
全局字符常量使用C风格字符串。
。大多数全局变量应该是类的静态
数据成员，或者当其只在.cc 文件中使用时，将其定义到不具名命名空间中，或者使用静态
关联以限制变量的作用域。































